<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
    <title>üåç Interactive World Cities - Neon Globe Visualization üåé</title>  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#00000b; --panel:rgba(3,12,20,0.78); --muted:#bfe9ff; --accent:#66f0ff;
              
        /* Creative Animation Keyframes */
        @keyframes rainbowGlow {
            0% { filter: hue-rotate(0deg) drop-shadow(0 0 20px currentColor); }
            25% { filter: hue-rotate(90deg) drop-shadow(0 0 30px currentColor); }
            50% { filter: hue-rotate(180deg) drop-shadow(0 0 40px currentColor); }
            75% { filter: hue-rotate(270deg) drop-shadow(0 0 30px currentColor); }
            100% { filter: hue-rotate(360deg) drop-shadow(0 0 20px currentColor); }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.15); opacity: 0.8; }
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            33% { transform: translateY(-15px) rotate(5deg); }
            66% { transform: translateY(-8px) rotate(-5deg); }
        }
        
        @keyframes shimmer {
            0% { background-position: -1000px 0; }
            100% { background-position: 1000px 0; }
        }
    }
    html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,Segoe UI,Roboto,Arial;overflow:hidden;color:var(--muted)}
        
        /* Animated gradient background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(0, 255, 200, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(138, 43, 226, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 20%, rgba(255, 20, 147, 0.1) 0%, transparent 50%);
            animation: float 20s ease-in-out infinite;
            pointer-events: none;
            z-index: 1;
        }
    #canvas-container{width:100vw;height:100vh;position:relative}
    #controls{position:absolute;right:16px;top:16px;z-index:60;background:var(--panel);padding:12px;border-radius:10px;min-width:260px;box-shadow:0 10px 36px rgba(0,0,0,0.6)}
    #controls .row{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
    #controls .btn{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:6px 8px;border-radius:8px;cursor:pointer} transition: all 0.3s ease;
    #controls .primary{background:linear-gradient(90deg,#00e5ff22,#7affb922);border:none}
    #caption{position:absolute;left:50%;transform:translateX(-50%);bottom:22px;padding:10px 14px;background:var(--panel);border-radius:10px;z-index:55;min-width:320px;text-align:center;box-shadow:0 10px 30px rgba(0,0,0,0.6)}
    #hint{position:absolute;left:16px;top:16px;padding:8px 10px;border-radius:8px;background:rgba(0,0,0,0.24);backdrop-filter:blur(6px);z-index:60}
    #tooltip{position:absolute;pointer-events:none;z-index:70;transform:translate(-50%,-120%);padding:8px 12px;border-radius:8px;background:rgba(3,12,20,0.9);color:#bff7ff;font-size:13px;display:none}
    #fps{position:absolute;right:16px;bottom:16px;color:#8ef;z-index:60;font-size:12px}
    #notesPanel{position:absolute;left:16px;bottom:16px;width:360px;max-height:50vh;overflow:auto;background:var(--panel);padding:12px;border-radius:10px;z-index:61;box-shadow:0 10px 30px rgba(0,0,0,0.6);display:none}
    #notesPanel h3{margin:0 0 8px 0;color:var(--accent)}
    .kbd{display:inline-block;padding:4px 8px;border-radius:6px;background:rgba(255,255,255,0.03);margin-left:6px;font-size:12px}
    #scriptBlock{white-space:pre-wrap;margin-top:10px;font-size:13px;line-height:1.3;color:#dff}
    .small{font-size:12px;color:#9fe6ff}
        #controls .btn:hover {
            transform: scale(1.1) translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 255, 178, 0.4);
            animation: pulse 2s ease-in-out infinite;
        }
        
        /* Add rainbow glow to primary button */
        #controls .primary:hover {
            animation: rainbowGlow 3s ease-in-out infinite, pulse 2s ease-in-out infinite;
        }
  </style>
</head>
<body>
  <div id="canvas-container">
    <div id="hint">Drag ‚Ä¢ Scroll ‚Ä¢ Hover icons ‚Ä¢ Click nodes ‚Ä¢ Controls on the right</div>

    <div id="controls">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <strong style="color:var(--accent)">Neon Globe ‚Äî Presentation</strong>
        <div>
          <button id="fullscreenBtn" class="btn" title="Fullscreen">‚§¢</button>
          <button id="notesToggle" class="btn" title="Toggle speaker notes">üìù Notes</button>
            <strong style="color:var(--accent)">üåé Interactive World Cities Globe üåü</strong>      </div>

      <div class="row"><label>Bloom</label><input id="bloomToggle" type="checkbox" checked></div>
      <div class="row"><label>Stars</label><input id="starsToggle" type="checkbox" checked></div>
      <div class="row"><label>Aurora</label><input id="auroraToggle" type="checkbox" checked></div>
      <div style="margin:8px 0" class="row"><label>Globe speed</label><input id="speedRange" type="range" min="0" max="2" step="0.01" value="1"></div>

      <div style="display:flex;gap:8px;margin-top:6px">
        <button id="prevBtn" class="btn">‚óÄ Prev</button>
        <button id="playBtn" class="btn primary">‚ñ∫ Play Tour</button>
        <button id="nextBtn" class="btn">Next ‚ñ∂</button>
        <button id="screenshotBtn" class="btn" title="Screenshot">üì∏</button>
      </div>

      <div style="margin-top:10px;font-size:13px;color:#9fe6ff">
        Keyboard:
        <span class="kbd">‚Üê/‚Üí / A / D</span> orbit,
        <span class="kbd">‚Üë/‚Üì / W / S</span> tilt,
        <span class="kbd">+ / -</span> zoom,
        <span class="kbd">1-5</span> jump nodes,
        <span class="kbd">p</span> play/pause
      </div>
    </div>

    <div id="caption">Welcome ‚Äî start the tour to highlight key sustainable innovations.</div>
    <div id="tooltip"></div>
    <div id="fps"></div>

    <div id="notesPanel">
      <h3>Speaker Notes ‚Äî current step</h3>
      <div id="notesContent" class="small">Press Play to start the tour. Speaker notes will appear here for each node.</div>
      <div style="margin-top:10px"><strong>Short script (75s)</strong>
        <div id="scriptBlock">(script will appear here)</div>
      </div>
    </div>
  </div>

<script type="module">
/* Neon Globe ‚Äî added keyboard camera controls, speaker notes mapped to each node,
   and a short 75-second script. Single-file, run via Live Server or local HTTP.
*/
import * as THREE from "https://cdn.skypack.dev/three@0.128.0";
import { OrbitControls } from "https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js";
import { EffectComposer } from "https://cdn.skypack.dev/three@0.128.0/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "https://cdn.skypack.dev/three@0.128.0/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "https://cdn.skypack.dev/three@0.128.0/examples/jsm/postprocessing/UnrealBloomPass.js";

/* ---------- DOM ---------- */
const container = document.getElementById('canvas-container');
const captionEl = document.getElementById('caption');
const tooltip = document.getElementById('tooltip');
const fpsEl = document.getElementById('fps');

const playBtn = document.getElementById('playBtn');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const screenshotBtn = document.getElementById('screenshotBtn');
const bloomToggle = document.getElementById('bloomToggle');
const starsToggle = document.getElementById('starsToggle');
const auroraToggle = document.getElementById('auroraToggle');
const speedRange = document.getElementById('speedRange');
const fullscreenBtn = document.getElementById('fullscreenBtn');
const notesToggle = document.getElementById('notesToggle');
const notesPanel = document.getElementById('notesPanel');
const notesContent = document.getElementById('notesContent');
const scriptBlock = document.getElementById('scriptBlock');
const hint = document.getElementById('hint');

/* ---------- Scene / Renderer / Camera / Controls ---------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x00000b);

const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 6000);
camera.position.set(0, 160, 420);

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
container.appendChild(renderer.domElement);

const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.9, 1.0, 0.08);
bloomPass.threshold = 0.1; bloomPass.strength = 0.9; bloomPass.radius = 0.5;
composer.addPass(bloomPass);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor = 0.08;
controls.minDistance = 140; controls.maxDistance = 900;

/* ---------- Globals ---------- */
const RADIUS = 122;
let globeSpeedFactor = parseFloat(speedRange.value);

/* ---------- Speaker notes & short script ---------- */
const speakerNotes = [
  { id: 1, title: 'Solar Innovation', note: 'Highlight distributed solar microgrids and battery storage. Mention local impact, affordability, and scalability.' },
  { id: 2, title: 'Wind Tech', note: 'Describe offshore wind arrays, turbine advances, and how wind complements solar in a grid.' },
  { id: 3, title: 'Green City', note: 'Talk about green roofs, transit-oriented design, and how nature-based solutions reduce urban heat.' },
  { id: 4, title: 'Recycle Hub', note: 'Explain circular material flows, industrial symbiosis, and consumer-level recycling improvements.' },
  { id: 5, title: 'Ethical Forum', note: 'Close with governance, community voices, and ethics guiding tech deployment.' }
];

// 75-second script (approx) for running while the tour auto-plays
const shortScript = `Hello ‚Äî welcome to our Creative Sustainable Globe demonstration.
Over the next minute, we'll travel to five hubs of sustainable innovation:
First, Solar Innovation ‚Äî microgrids and storage are transforming access to energy, especially in remote areas.
Next, Wind Tech ‚Äî modern offshore turbines offer powerful capacity and complement solar output.
Then, Green City ‚Äî urban design and green infrastructure cool cities and improve quality of life.
After that, Recycle Hub ‚Äî circular systems reduce waste and recover valuable materials.
Finally, Ethical Forum ‚Äî policy and community engagement ensure technologies are used responsibly.
Together, these areas show that technology, policy, and people must work in harmony.
Thank you ‚Äî press pause to explore any node in detail.`;

scriptBlock.innerText = shortScript;

/* ---------- Starfield ---------- */
let starPoints = null;
function makeStarField(count=1300, radius=2200){
  if (starPoints) scene.remove(starPoints);
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count*3);
  for (let i=0;i<count;i++){
    const phi = Math.acos(2*Math.random()-1);
    const theta = 2*Math.PI*Math.random();
    const r = radius*(0.82 + Math.random()*0.36);
    pos[i*3]   = r*Math.sin(phi)*Math.cos(theta);
    pos[i*3+1] = r*Math.cos(phi);
    pos[i*3+2] = r*Math.sin(phi)*Math.sin(theta);
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
  const mat = new THREE.PointsMaterial({ size: Math.random()*0.8 + 0.5, transparent:true, opacity:0.95 });
  mat.color = new THREE.Color(0x66e8ff);
  starPoints = new THREE.Points(geo, mat);
  scene.add(starPoints);
}
makeStarField();

/* ---------- Aurora ---------- */
function createAuroraCanvas(w=2048,h=256){
  const c=document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d');
  const g=ctx.createLinearGradient(0,0,w,0);
  g.addColorStop(0,'rgba(0,220,200,0.0)'); g.addColorStop(0.3,'rgba(40,220,255,0.12)');
  g.addColorStop(0.6,'rgba(200,140,255,0.08)'); g.addColorStop(1,'rgba(140,255,180,0)');
  ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
  for(let i=0;i<40;i++){ ctx.globalAlpha=0.03+Math.random()*0.06; ctx.fillStyle='white'; ctx.fillRect(Math.random()*w,Math.random()*h,180+Math.random()*600,8+Math.random()*14); }
  return new THREE.CanvasTexture(c);
}
const auroraTex = createAuroraCanvas();
const auroraA = (() => {
  const g = new THREE.PlaneGeometry(1400,120);
  const m = new THREE.MeshBasicMaterial({ map: auroraTex, transparent:true, opacity:0.12, blending: THREE.AdditiveBlending, depthWrite:false });
  const p = new THREE.Mesh(g,m); p.rotation.x = 0.22; p.rotation.z = 0.42; p.position.y = 140; p.position.z = -80; scene.add(p); return p;
})();
const auroraB = (() => {
  const g = new THREE.PlaneGeometry(1200,100);
  const m = new THREE.MeshBasicMaterial({ map: auroraTex, transparent:true, opacity:0.08, blending: THREE.AdditiveBlending, depthWrite:false });
  const p = new THREE.Mesh(g,m); p.rotation.x = 0.22; p.rotation.z = -0.32; p.position.y = 120; p.position.z = -70; scene.add(p); return p;
})();

/* ---------- Earth + clouds + rim ---------- */
const earthGeom = new THREE.SphereGeometry(RADIUS, 96, 96);
function createEarthTexture(){
  const s=2048; const c=document.createElement('canvas'); c.width=c.height=s; const ctx=c.getContext('2d');
  const g = ctx.createLinearGradient(0,0,s,s); g.addColorStop(0,'#001a2b'); g.addColorStop(1,'#023b5a'); ctx.fillStyle=g; ctx.fillRect(0,0,s,s);
  ctx.fillStyle='#1f8b4f'; ctx.globalAlpha=0.95;
  ctx.beginPath(); ctx.ellipse(s*0.65,s*0.56,520,300,-0.18,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(s*0.35,s*0.38,340,210,0.26,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(s*0.5,s*0.8,260,140,0.65,0,Math.PI*2); ctx.fill();
  ctx.globalCompositeOperation='lighter'; ctx.fillStyle='rgba(120,200,150,0.04)';
  for(let i=0;i<2400;i++){ ctx.beginPath(); ctx.arc(Math.random()*s, Math.random()*s, Math.random()*3,0,Math.PI*2); ctx.fill(); }
  return new THREE.CanvasTexture(c);
}
const earthMat = new THREE.MeshPhongMaterial({ map: createEarthTexture(), shininess:8, specular:0x223344 });
const earth = new THREE.Mesh(earthGeom, earthMat); scene.add(earth);

// clouds
const cloudGeom = new THREE.SphereGeometry(RADIUS + 1.8, 96, 96);
const cloudTex = (() => { const c=document.createElement('canvas'); c.width=c.height=1024; const ctx=c.getContext('2d'); ctx.fillStyle='rgba(255,255,255,0.02)'; for(let i=0;i<2500;i++){ ctx.beginPath(); ctx.arc(Math.random()*1024, Math.random()*1024, Math.random()*7+1, 0, Math.PI*2); ctx.fill(); } return new THREE.CanvasTexture(c); })();
const clouds = new THREE.Mesh(cloudGeom, new THREE.MeshLambertMaterial({ map: cloudTex, transparent:true, opacity:0.6, depthWrite:false }));
scene.add(clouds);

// rim
scene.add(new THREE.Mesh(new THREE.SphereGeometry(RADIUS+8,64,64), new THREE.MeshBasicMaterial({ color:0x25e6ff, transparent:true, opacity:0.04, blending:THREE.AdditiveBlending, side:THREE.BackSide })));

/* ---------- Rings ---------- */
const ringsGroup = new THREE.Group(); scene.add(ringsGroup);
function addRing(radius, thickness, color, speed, tilt){
  const geo = new THREE.TorusGeometry(radius, thickness, 24, 240);
  const mat = new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.26, blending:THREE.AdditiveBlending });
  const mesh = new THREE.Mesh(geo, mat); mesh.rotation.x = tilt; mesh.userData = { speed }; ringsGroup.add(mesh);
}
addRing(RADIUS+18, 0.85, 0x1fe6ff, 0.003, 0.12);
addRing(RADIUS+30, 1.1, 0x6affb2, 0.0019, -0.06);
addRing(RADIUS+46, 1.4, 0xffc86b, 0.0012, 0.04);

/* ---------- Icons ---------- */
function makeIconTexture(symbol, bg, fg){
  const s=512; const cv=document.createElement('canvas'); cv.width=cv.height=s; const ctx=cv.getContext('2d');
  const rg=ctx.createRadialGradient(s/2,s/2,20,s/2,s/2,260); rg.addColorStop(0,bg); rg.addColorStop(1,'rgba(0,0,0,0)'); ctx.fillStyle=rg; ctx.fillRect(0,0,s,s);
  ctx.fillStyle=fg; ctx.font='bold 220px serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(symbol,s/2,s/2+6);
  return new THREE.CanvasTexture(cv);
}
const icons = {
  solar: makeIconTexture('‚òÄ','#003f7f','#ffd36b'),
  wind: makeIconTexture('‚ú¶','#003b40','#b6f6ff'),
  recycle: makeIconTexture('‚ôª','#0b6b2f','#b8ffb4'),
  ethics: makeIconTexture('‚öñ','#17204d','#a7b6ff'),
  building: makeIconTexture('‚ñ¶','#1e2b2b','#aaffd1')
};

/* ---------- Nodes & interactive list ---------- */
const iconGroup = new THREE.Group(); scene.add(iconGroup);
const interactive = [];

const placedNodes = [
{ name: 'New York üóΩ', lat: 40.7128, lon: -74.0060, text: icons.building, color: 0x1eff6f, desc: 'Tech innovation hub & financial center.' },
    { name: 'London üá¨üáß', lat: 51.5074, lon: -0.1278, text: icons.wind, color: 0x66ffb2, desc: 'Green energy & smart city initiatives.' },
    { name: 'Tokyo üáØüáµ', lat: 35.6762, lon: 139.6503, text: icons.solar, color: 0x1fe8ff, desc: 'Advanced robotics & clean technology.' },
    { name: 'Paris üá´üá∑', lat: 48.8566, lon: 2.3522, text: icons.building, color: 0xff6fb2, desc: 'Sustainable urban development.' },
    { name: 'Dubai üá¶üá™', lat: 25.2048, lon: 55.2708, text: icons.solar, color: 0xffd700, desc: 'Solar power & futuristic architecture.' },
    { name: 'Singapore üá∏üá¨', lat: 1.3521, lon: 103.8198, text: icons.recycle, color: 0x00ff88, desc: 'Zero-waste smart nation.' },
    { name: 'Mumbai üáÆüá≥', lat: 19.0760, lon: 72.8777, text: icons.building, color: 0xff9933, desc: 'Emerging tech startup ecosystem.' },
    { name: 'S√£o Paulo üáßüá∑', lat: -23.5505, lon: -46.6333, text: icons.ethics, color: 0x66ff66, desc: 'Renewable energy & sustainability.' },
    { name: 'Sydney üá¶üá∫', lat: -33.8688, lon: 151.2093, text: icons.wind, color: 0x00ccff, desc: 'Coastal wind farms & clean energy.' },
    { name: 'Berlin üá©üá™', lat: 52.5200, lon: 13.4050, text: icons.recycle, color: 0xffcc00, desc: 'Circular economy pioneer.' },
    { name: 'Toronto üá®üá¶', lat: 43.6532, lon: -79.3832, text: icons.building, color: 0xff6666, desc: 'Green building standards leader.' },
    { name: 'Seoul üá∞üá∑', lat: 37.5665, lon: 126.9780, text: icons.solar, color: 0xff00ff, desc: 'Smart city & 5G technology.' },
    { name: 'Moscow üá∑üá∫', lat: 55.7558, lon: 37.6173, text: icons.wind, color: 0xccccff, desc: 'Energy transition initiatives.' },
    { name: 'Mexico City üá≤üáΩ', lat: 19.4326, lon: -99.1332, text: icons.recycle, color: 0x00ff00, desc: 'Urban recycling programs.' },
    { name: 'Cape Town üáøüá¶', lat: -33.9249, lon: 18.4241, text: icons.wind, color: 0x66d9ff, desc: 'Wind energy & ocean conservation.' },
    { name: 'Bangkok üáπüá≠', lat: 13.7563, lon: 100.5018, text: icons.building, color: 0xffaa00, desc: 'Smart transportation systems.' },
    { name: 'Istanbul üáπüá∑', lat: 41.0082, lon: 28.9784, text: icons.solar, color: 0xff3366, desc: 'Bridge between Europe & Asia tech.' },
    { name: 'Los Angeles üá∫üá∏', lat: 34.0522, lon: -118.2437, text: icons.solar, color: 0xffdd44, desc: 'Solar power capital of America.' },
    { name: 'Shanghai üá®üá≥', lat: 31.2304, lon: 121.4737, text: icons.building, color: 0xff0066, desc: 'Mega city innovation center.' },
    { name: 'Amsterdam üá≥üá±', lat: 52.3676, lon: 4.9041, text: icons.recycle, color: 0x66ff99, desc: 'Bicycle culture & green living.' }

function latLonToVector3(lat, lon, offset=0){
  const phi = (90 - lat) * (Math.PI / 180);
  const theta = (lon + 180) * (Math.PI / 180);
  const r = RADIUS + offset;
  return new THREE.Vector3(
    r * Math.sin(phi) * Math.cos(theta),
    r * Math.cos(phi),
    r * Math.sin(phi) * Math.sin(theta)
  );
}
function createLabelSprite(text){
  const s=512; const cv=document.createElement('canvas'); cv.width=cv.height=s; const ctx=cv.getContext('2d');
  ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,s*0.38,s,s*0.26);
  ctx.fillStyle='#bff7ff'; ctx.font='bold 46px sans-serif'; ctx.textAlign='center'; ctx.fillText(text,s/2,s*0.52);
  const tex=new THREE.CanvasTexture(cv);
  const mat = new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false });
  const sp = new THREE.Sprite(mat); sp.scale.set(62,28,1); return sp;
}
placedNodes.forEach(n => {
  const pos = latLonToVector3(n.lat, n.lon, 10);
  const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: n.tex, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending }));
  spr.scale.set(22,22,1); spr.position.copy(pos); iconGroup.add(spr);

  const pedestal = new THREE.Mesh(new THREE.SphereGeometry(1.2,8,8), new THREE.MeshBasicMaterial({ color:n.color, blending:THREE.AdditiveBlending, transparent:true, opacity:0.95 }));
  pedestal.position.copy(latLonToVector3(n.lat, n.lon, 1.2)); iconGroup.add(pedestal);

  const label = createLabelSprite(n.name); label.position.copy(latLonToVector3(n.lat, n.lon, 26)); iconGroup.add(label);

  // arc and moving point along curve
  const surface = latLonToVector3(n.lat, n.lon, 0.6);
  const controlHigh = latLonToVector3(n.lat + (n.lat>0?10:-10), n.lon + 22, 44);
  const curve = new THREE.CatmullRomCurve3([surface, controlHigh, pos]);
  const tubeGeom = new THREE.TubeGeometry(curve, 64, 0.6, 8, false);
  const tubeMat = new THREE.MeshBasicMaterial({ color: n.color, transparent:true, opacity:0.18, blending:THREE.AdditiveBlending });
  const tube = new THREE.Mesh(tubeGeom, tubeMat); scene.add(tube);

  const mover = new THREE.Mesh(new THREE.SphereGeometry(0.9,8,8), new THREE.MeshBasicMaterial({ color:n.color, blending:THREE.AdditiveBlending }));
  mover.userData = { curve, t: Math.random(), speed: 0.0015 + Math.random()*0.0021 };
  scene.add(mover);

  interactive.push({ object: spr, name: n.name, desc: n.desc, sprite: spr, pedestal, mover, curve, focusPos: pos.clone() });
});

/* ---------- Flow triangle ---------- */
const flowGroup = new THREE.Group(); scene.add(flowGroup);
const triangle = [
  { lat: 34, lon: -18, label: 'Engineering', color: 0x89f7ff },
  { lat: -10, lon: 60, label: 'Society', color: 0x99ffb8 },
  { lat: 18, lon: 130, label: 'Ethics', color: 0xc6bfff }
];
const triNodes = triangle.map(n => {
  const p = latLonToVector3(n.lat, n.lon, 18);
  const dot = new THREE.Mesh(new THREE.SphereGeometry(3.5,12,12), new THREE.MeshBasicMaterial({ color:n.color, transparent:true, opacity:0.85, blending:THREE.AdditiveBlending }));
  dot.position.copy(p); flowGroup.add(dot);
  const lbl = createLabelSprite(n.label); lbl.position.copy(latLonToVector3(n.lat,n.lon,34)); flowGroup.add(lbl);
  return { ...n, pos: p };
});
function connectFlow(a,b,colorHex){
  const mid = a.pos.clone().add(b.pos).multiplyScalar(0.5).multiplyScalar(1.18);
  const curve = new THREE.CatmullRomCurve3([a.pos, mid, b.pos]);
  const tube = new THREE.TubeGeometry(curve, 64, 1.6, 16, false);
  const mat = new THREE.MeshBasicMaterial({ color: colorHex, transparent:true, opacity:0.11, blending: THREE.AdditiveBlending });
  const mesh = new THREE.Mesh(tube, mat); flowGroup.add(mesh);
  const mover = new THREE.Mesh(new THREE.SphereGeometry(1.2,8,8), new THREE.MeshBasicMaterial({ color: colorHex, blending: THREE.AdditiveBlending }));
  mover.userData = { curve, t: Math.random()*0.5 + 0.05, speed: 0.0008 + Math.random()*0.001 };
  flowGroup.add(mover);
  return mover;
}
const movers = [ connectFlow(triNodes[0],triNodes[1],0x89f7ff), connectFlow(triNodes[1],triNodes[2],0x99ffb8), connectFlow(triNodes[2],triNodes[0],0xc6bfff) ];

/* ---------- Satellites ---------- */
const satellites = new THREE.Group(); scene.add(satellites);
function makeOrbit(angleOffset, radius, speed, spriteTex){
  const g = new THREE.Group(); g.userData = { angle: angleOffset, radius, speed };
  const sp = new THREE.Sprite(new THREE.SpriteMaterial({ map: spriteTex, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending }));
  sp.scale.set(20,20,1); g.add(sp); satellites.add(g); return g;
}
makeOrbit(0.2, RADIUS + 62, 0.0015, icons.solar);
makeOrbit(1.1, RADIUS + 78, 0.0011, icons.wind);
makeOrbit(2.1, RADIUS + 92, 0.0009, icons.recycle);

/* ---------- Lights ---------- */
scene.add(new THREE.AmbientLight(0x66d9ff, 0.8));
const dir = new THREE.DirectionalLight(0xfff3b0, 0.9); dir.position.set(480,260,320); scene.add(dir);
const rim = new THREE.PointLight(0x65e6ff, 0.24, 1000); rim.position.set(-220,200,-220); scene.add(rim);

/* ---------- Raycast / Interaction ---------- */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let hovered = null;
let lastPointer = { clientX: innerWidth/2, clientY: innerHeight/2, x:0, y:0 };
function onPointerMove(ev){
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
  lastPointer.clientX = ev.clientX; lastPointer.clientY = ev.clientY;
}
window.addEventListener('pointermove', onPointerMove);
function onPointerDown(ev){
  const rect = renderer.domElement.getBoundingClientRect();
  const nx = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
  const ny = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera({ x:nx, y:ny }, camera);
  const list = interactive.map(i=>i.object);
  const ints = raycaster.intersectObjects(list, true);
  if (ints.length > 0){
    const spr = ints[0].object;
    const hit = interactive.find(i => i.object === spr || i.object.uuid === spr.uuid);
    if (hit) showDetail(hit);
  }
}
window.addEventListener('pointerdown', onPointerDown);

function showDetail(hit){
  captionEl.innerHTML = `<strong>${hit.name}</strong> ‚Äî ${hit.desc}`;
  hit.sprite.scale.set(30,30,1);
  hit.pedestal.scale.set(1.6,1.6,1.6);
  setTimeout(()=>{ hit.sprite.scale.set(22,22,1); hit.pedestal.scale.set(1,1,1); }, 1600);
  // update notes panel
  const idx = placedNodes.findIndex(p => p.name === hit.name);
  if (idx >= 0) updateNotes(idx);
}

function handleHover(){
  raycaster.setFromCamera(mouse, camera);
  const list = interactive.map(i=>i.object);
  const ints = raycaster.intersectObjects(list, true);
  if (ints.length > 0){
    const spr = ints[0].object;
    const hit = interactive.find(i => i.object === spr || i.object.uuid === spr.uuid);
    if (hit){
      if (hovered && hovered.object === hit.object){
        tooltip.style.left = (lastPointer.clientX) + 'px'; tooltip.style.top = (lastPointer.clientY - 8) + 'px';
        return;
      }
      hovered = hit;
      tooltip.style.display = 'block';
      tooltip.innerText = hit.name;
      tooltip.style.left = (lastPointer.clientX) + 'px'; tooltip.style.top = (lastPointer.clientY - 8) + 'px';
      hit.sprite.scale.set(28,28,1); hit.pedestal.scale.set(1.4,1.4,1.4);
    }
    return;
  }
  if (hovered){ hovered.sprite.scale.set(22,22,1); hovered.pedestal.scale.set(1,1,1); }
  hovered = null; tooltip.style.display = 'none';
}

/* ---------- Camera tween & tour ---------- */
let tourIndex = 0;
let tourPlaying = false;
let tourTimer = 0;
const tourDuration = 4200;

const camLerp = { fromPos: camera.position.clone(), toPos: camera.position.clone(), fromTarget: new THREE.Vector3(0,0,0), toTarget: new THREE.Vector3(0,0,0), t: 1 };

function focusOnNode(index, immediate=false){
  const item = interactive[index];
  if (!item) return;
  const dir = item.focusPos.clone().normalize();
  const toTarget = item.focusPos.clone();
  const toPos = item.focusPos.clone().add(dir.multiplyScalar(180)).add(new THREE.Vector3(0,24,0));
  if (immediate){ camera.position.copy(toPos); controls.target.copy(toTarget); controls.update(); }
  else {
    camLerp.fromPos = camera.position.clone(); camLerp.toPos = toPos.clone();
    camLerp.fromTarget = controls.target.clone(); camLerp.toTarget = toTarget.clone();
    camLerp.t = 0;
  }
  captionEl.innerHTML = `<strong>${item.name}</strong> ‚Äî ${item.desc}`;
  updateNotes(index);
}

function nextTour(){ tourIndex = (tourIndex + 1) % interactive.length; focusOnNode(tourIndex); }
function prevTour(){ tourIndex = (tourIndex - 1 + interactive.length) % interactive.length; focusOnNode(tourIndex); }

/* UI handlers */
playBtn.addEventListener('click', ()=>{ tourPlaying = !tourPlaying; playBtn.innerText = tourPlaying ? '‚ùö‚ùö Pause' : '‚ñ∫ Play Tour'; if (tourPlaying) tourTimer = performance.now(); });
nextBtn.addEventListener('click', ()=>{ nextTour(); tourPlaying=false; playBtn.innerText='‚ñ∫ Play Tour'; });
prevBtn.addEventListener('click', ()=>{ prevTour(); tourPlaying=false; playBtn.innerText='‚ñ∫ Play Tour'; });
screenshotBtn.addEventListener('click', ()=>{ renderer.domElement.toBlob(blob=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='neon-globe-screenshot.png'; a.click(); }); });
bloomToggle.addEventListener('change', e=>{ bloomPass.enabled = e.target.checked; });
starsToggle.addEventListener('change', e=>{ if (starPoints) starPoints.visible = e.target.checked; });
auroraToggle.addEventListener('change', e=>{ auroraA.visible = auroraB.visible = e.target.checked; });
speedRange.addEventListener('input', e=>{ globeSpeedFactor = parseFloat(e.target.value); });
fullscreenBtn.addEventListener('click', ()=>{ if (!document.fullscreenElement){ document.documentElement.requestFullscreen(); document.getElementById('controls').style.display='none'; hint.style.display='none'; notesPanel.style.display='none'; } else { document.exitFullscreen(); document.getElementById('controls').style.display=''; hint.style.display=''; } });
notesToggle.addEventListener('click', ()=>{ notesPanel.style.display = notesPanel.style.display === 'none' ? 'block' : 'none'; });

/* Keyboard cinematic controls:
   - Arrow keys / WASD rotate camera target around globe center
   - + / - zoom in/out
   - 1..5 jump to nodes
   - p play/pause tour
*/
const keyState = {};
window.addEventListener('keydown', (e) => { keyState[e.key.toLowerCase()] = true; handleKeyDown(e); });
window.addEventListener('keyup', (e) => { keyState[e.key.toLowerCase()] = false; });

function handleKeyDown(e){
  const k = e.key.toLowerCase();
  if (k === 'p'){ tourPlaying = !tourPlaying; playBtn.innerText = tourPlaying ? '‚ùö‚ùö Pause' : '‚ñ∫ Play Tour'; if (tourPlaying) tourTimer = performance.now(); }
  if (k >= '1' && k <= '5'){ const idx = parseInt(k) - 1; if (interactive[idx]){ focusOnNode(idx); tourPlaying=false; playBtn.innerText='‚ñ∫ Play Tour'; } }
  // immediate camera nudges via arrow keys:
  if (k === '+' || k === '='){ camera.position.add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(-24)); } // zoom out
  if (k === '-') { camera.position.add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(24)); } // zoom in
}

/* We'll also handle continuous keyboard-based orbiting in animate() */

/* ---------- Animation loop ---------- */
const clock = new THREE.Clock();
let lastPerf = performance.now();

function updateNotes(index){
  const note = speakerNotes[index];
  if (note){
    notesContent.innerHTML = `<strong>${note.title}</strong><div style="margin-top:8px">${note.note}</div>`;
  } else {
    notesContent.innerHTML = 'No notes available for this step.';
  }
}

function animate(){
  const dt = clock.getDelta(); const t = clock.getElapsedTime();

  // earth / clouds
  earth.rotation.y += 0.0009 * globeSpeedFactor;
  clouds.rotation.y += 0.0013 * globeSpeedFactor;

  // rings
  ringsGroup.children.forEach(c => { c.rotation.z += (c.userData.speed || 0.001) * (1 + Math.sin(t*0.2)*0.08); c.rotation.y += (c.userData.speed || 0.001) * 0.18; });

  // movers along arcs
  interactive.forEach(it => {
    if (it.mover && it.mover.userData && it.mover.userData.curve){
      it.mover.userData.t += it.mover.userData.speed;
      if (it.mover.userData.t > 1) it.mover.userData.t = 0;
      const p = it.mover.userData.curve.getPointAt(it.mover.userData.t);
      it.mover.position.copy(p);
    }
  });

  // triangle movers
  movers.forEach(m => { m.userData.t += m.userData.speed; if (m.userData.t>1) m.userData.t=0; const p = m.userData.curve.getPointAt(m.userData.t); m.position.copy(p); });

  // satellites
  satellites.children.forEach(g => {
    g.userData.angle += g.userData.speed * (1 + Math.sin(t*0.2)*0.12);
    const a = g.userData.angle, rad = g.userData.radius;
    g.position.set(Math.cos(a)*rad, Math.sin(a*0.6)*18, Math.sin(a)*rad);
    g.lookAt(0,0,0);
  });

  // keyboard continuous camera nudges:
  const orbitSpeed = 0.8 * dt;
  if (keyState['arrowleft'] || keyState['a']) { controls.rotateLeft(orbitSpeed); }
  if (keyState['arrowright'] || keyState['d']) { controls.rotateLeft(-orbitSpeed); }
  if (keyState['arrowup'] || keyState['w']) { controls.rotateUp(orbitSpeed); }
  if (keyState['arrowdown'] || keyState['s']) { controls.rotateUp(-orbitSpeed); }
  if (keyState['+'] || keyState['=']) { camera.position.add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(-8)); }
  if (keyState['-']) { camera.position.add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(8)); }

  // camera lerp
  if (camLerp.t < 1){
    camLerp.t = Math.min(1, camLerp.t + dt * 1.6);
    camera.position.lerpVectors(camLerp.fromPos, camLerp.toPos, camLerp.t);
    controls.target.lerpVectors(camLerp.fromTarget, camLerp.toTarget, camLerp.t);
  }

  // tour auto-advance
  if (tourPlaying){
    if (!tourTimer) tourTimer = performance.now();
    if (performance.now() - tourTimer > tourDuration){ tourTimer = performance.now(); nextTour(); }
  }

  handleHover();
  controls.update();

  composer.render();

  // fps
  const nowPerf = performance.now();
  const fps = Math.round(1000 / Math.max(1, nowPerf - lastPerf));
  fpsEl.innerText = `${fps} FPS`;
  lastPerf = nowPerf;

  requestAnimationFrame(animate);
}
animate();

/* ---------- Initial focus & setup ---------- */
function initPostSetup(){
  if (interactive.length > 0){
    tourIndex = 0; focusOnNode(0, true); setTimeout(()=> captionEl.innerText = 'Ready ‚Äî press Play to start the tour.', 900);
    // populate notes for first node
    updateNotes(0);
  }
}
initPostSetup();

/* ---------- Resize ---------- */
window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight); composer.setSize && composer.setSize(innerWidth, innerHeight);
});

/* ---------- Console tip ---------- */
console.log('Neon Globe ‚Äî keyboard controls (arrow/WASD, +/- zoom, 1-5 jump), notes panel, and short script available.');

</script>
</body>
</html>
